// ... (Toute la partie HTML/CSS reste identique) ...

// Remplacer TOUT le bloc script de index_1m.html par ceci :

<script>
// --- JAVASCRIPT SYSTEME (NE PAS TOUCHER) ---
let btcData = []; 
let currentSlot = 1;

function selectSlot(num) {
    currentSlot = num;
    document.querySelectorAll('.slot-btn').forEach((btn, idx) => btn.className = (idx + 1 === num) ? 'slot-btn active' : 'slot-btn');
    loadSlotConfig(num);
}
function saveCurrentConfig() {
    const config = { capital: document.getElementById('startCap').value, script: document.getElementById('strategyScript').value };
    localStorage.setItem('gas_sim_slot_' + currentSlot, JSON.stringify(config));
    alert("Configuration sauvegardée !");
}
function loadSlotConfig(num) {
    const saved = localStorage.getItem('gas_sim_slot_' + num);
    if (saved) {
        const config = JSON.parse(saved);
        document.getElementById('startCap').value = config.capital;
        document.getElementById('strategyScript').value = config.script;
    }
}
function clearScript() {
    document.getElementById('strategyScript').value = '';
}

// === CHARGEMENT DES DONNÉES BINANCE (7 Jours @ 1 Minute) - UTILISE ENDTIME ===
async function loadDataBinance() {
    const status = document.getElementById('status');
    status.innerText = "Calcul du nombre de requêtes...";
    
    const TARGET_BOUGEES = 10080; 
    const LIMIT = 1000;
    const NUM_REQUETES = Math.ceil(TARGET_BOUGEES / LIMIT);
    
    let allData = [];
    let endTime = Date.now(); 
    
    try {
        for (let i = 0; i < NUM_REQUETES; i++) {
            status.innerText = `Chargement 1-Minutes (${i + 1}/${NUM_REQUETES})...`;
            
            const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=${LIMIT}&endTime=${endTime}`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (!data || data.length === 0) break;

            allData = data.concat(allData); 
            endTime = data[0][0]; 

            await new Promise(resolve => setTimeout(resolve, 50)); 
        }

        btcData = allData.slice(allData.length - TARGET_BOUGEES).map(c => parseFloat(c[4])); 
        
        status.innerHTML = `✅ <b>${btcData.length}</b> bougies chargées (7 jours @ 1m).`;
        document.getElementById('btnRun').disabled = false;
        
    } catch(e) { 
        status.innerText = "Erreur Web: Échec du chargement des données. " + e.message; 
        document.getElementById('btnRun').disabled = true;
    }
}
// =======================================================


function runSim() {
    const userScript = document.getElementById('strategyScript').value;
    const startCap = parseFloat(document.getElementById('startCap').value);
    const logsDiv = document.getElementById('logs');
    const status = document.getElementById('status');
    
    if (btcData.length === 0) return alert("Clique sur CHARGER DONNÉES d'abord.");
    logsDiv.innerHTML = "";

    // Moteur d'émulation
    const emulatorCode = `
        let _idx = 0;
        let _prices = pricesArray;
        let _mem = { 
            'TP_USDT': initialCapital, 
            'TP_BTC': 0.0, 
            'TP_AVG': 0.0 
        };
        let _logs = [];

        // Fonctions GAS simulées (restent les mêmes)
        const PropertiesService = {
            getScriptProperties: () => ({
                getProperty: (k) => _mem[k],
                setProperty: (k, v) => _mem[k] = parseFloat(v), 
                deleteProperty: (k) => delete _mem[k]
            })
        };
        const Logger = { log: (m) => {} };
        const ScriptApp = {
            getProjectTriggers: () => [],
            deleteTrigger: () => {},
            newTrigger: () => ({ timeBased: () => ({ everyMinutes: () => ({ create: () => {} }) }) })
        };
        const SpreadsheetApp = {
            getActiveSpreadsheet: () => ({
                getSheetByName: (n) => ({
                    getRange: (r, c, nr, nc) => ({
                        getValue: () => _prices[_idx],
                        getValues: () => {
                            const end = _idx; 
                            const start = Math.max(0, end - nr + 1);
                            return _prices.slice(start, end + 1).map(p => [p]);
                        }
                    }),
                    getLastRow: () => _idx + 2,
                    appendRow: (arr) => {}
                })
            })
        };

        // --- INJECTION DU SCRIPT UTILISATEUR OU DU SCRIPT DE TEST ---
        if (userScript.trim().length > 0) {
            // L'utilisateur a collé un script
            ${userScript}
        } else {
            // SCRIPT DE TEST DE BASE (Croisement SMA Simple)
            const FEES_RATE = 0.0009; 
            const TRADE_AMOUNT_USDT = 4.0; 
            const TP_CFG = {
                MAX_CAPITAL: 50.0, TAKE_PROFIT_PERCENT: 0.006,  
                STOP_LOSS_PERCENT: 0.007, SMA_FAST: 10, SMA_SLOW: 50,
                TREND_STRENGTH_MIN: 0.0001, 
            };
            function calculateSMA(data, period) {
                if (data.length < period) return null;
                let sum = 0;
                for (let i = data.length - period; i < data.length; i++) { sum += data[i]; }
                return sum / period;
            }
            
            function tp_loadState() {
                const props = PropertiesService.getScriptProperties();
                return {
                    usdt: parseFloat(props.getProperty("TP_USDT")) || TP_CFG.MAX_CAPITAL,
                    btc: parseFloat(props.getProperty("TP_BTC")) || 0.0,
                    avg: parseFloat(props.getProperty("TP_AVG")) || 0.0
                };
            }
            function tp_saveState(state) {
                const props = PropertiesService.getScriptProperties();
                props.setProperty("TP_USDT", state.usdt);
                props.setProperty("TP_BTC", state.btc);
                props.setProperty("TP_AVG", state.avg);
            }
            // Nom de la fonction défini dans le script de test
            function runTrendPullbackBot_1m() {
                const currentPrice = getLatestPrice();
                let state = tp_loadState();

                if (state.btc > 0) {
                    const currentGain = (currentPrice - state.avg) / state.avg;
                    if (currentGain >= TP_CFG.TAKE_PROFIT_PERCENT) {
                        const usdtReceived = state.btc * currentPrice * (1 - FEES_RATE);
                        state.usdt += usdtReceived;
                        state.btc = 0.0;
                        state.avg = 0.0;
                        logAction("SELL", currentPrice, usdtReceived / currentPrice, usdtReceived, "TAKE PROFIT");
                        tp_saveState(state);
                        return;
                    }
                    return; 
                }
                if (state.usdt < TRADE_AMOUNT_USDT) return; 

                const priceHistory = getPriceHistory(TP_CFG.SMA_SLOW);
                if (!priceHistory || priceHistory.length < TP_CFG.SMA_SLOW) return;

                const smaFast = calculateSMA(priceHistory, TP_CFG.SMA_FAST);
                const smaSlow = calculateSMA(priceHistory, TP_CFG.SMA_SLOW);
                if (!smaFast || !smaSlow) return;

                const isBullish = (smaFast > smaSlow);
                const trendStrength = (smaFast - smaSlow) / smaSlow;
                const isStrongTrend = trendStrength >= TP_CFG.TREND_STRENGTH_MIN;

                if (isBullish && isStrongTrend) {
                    const usdtUsed = TRADE_AMOUNT_USDT;
                    const btcBought = usdtUsed / currentPrice * (1 - FEES_RATE);
                    state.usdt -= usdtUsed;
                    state.btc += btcBought;
                    state.avg = currentPrice;
                    logAction("BUY", currentPrice, btcBought, usdtUsed, "BUY Croisement Simple (TEST)");
                    tp_saveState(state);
                }
            }
        }
        
        // Définition des fonctions utilitaires pour que le script utilisateur puisse les appeler
        const getLatestPrice = () => _prices[_idx];
        const getPriceHistory = (limit) => _prices.slice(Math.max(0, _idx - limit + 1), _idx + 1);
        const logAction = (type, price, assetAmount, usdtAmount, note) => {
            if (type === "BUY" || type === "SELL") {
                _logs.push({ idx: _idx, action: type, price: price, usdt: usdtAmount, note: note });
            }
        };

        // --- BOUCLE DE SIMULATION (VÉRIFIE MAINTENANT runTrendPullbackBot_1m) ---
        for(let i = 50; i < _prices.length; i++) {
            _idx = i;
            try { 
                if(typeof runTrendPullbackBot_1m === 'function') runTrendPullbackBot_1m();
            } catch(e){
                console.error("Erreur dans l'itération " + _idx + ": " + e.message);
            }
        }

        const finalPrice = _prices[_prices.length - 1];
        const finalUSDT = parseFloat(_mem['TP_USDT']);
        const finalBTC = parseFloat(_mem['TP_BTC']);
        return { total: finalUSDT + (finalBTC * finalPrice), logs: _logs, trades: _logs.length };
    `;

    try {
        const vm = new Function('pricesArray', 'initialCapital', 'userScript', emulatorCode);
        const result = vm(btcData, startCap, userScript);
        
        const pnl = result.total - startCap;
        const color = pnl >= 0 ? "#4caf50" : "#ff4d4d";
        document.getElementById('finalCapDisplay').value = result.total.toFixed(2) + " $";
        status.innerHTML = `Résultat : <b style="color:${color}">${(pnl>0?"+":"") + pnl.toFixed(2)}$</b> (${result.trades} Trades)`;

        result.logs.forEach(l => {
            const css = l.action === "BUY" ? "log-buy" : "log-sell";
            logsDiv.innerHTML += `<div class="log-entry ${css}">[${l.idx}] <b>${l.action}</b> @ ${l.price} | Solde: ${parseFloat(l.usdt).toFixed(2)} | ${l.note}</div>`;
        });
    } catch(e) {
        alert("Erreur critique du MOTEUR : " + e.message);
    }
}

// Charger la configuration du Slot 1 au démarrage
selectSlot(1);
</script>
</body>
</html>
