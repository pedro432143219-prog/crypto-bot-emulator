<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart DCA Emulator + VOLUME (365 Jours)</title>
    <style>
        /* STYLE (CSS) IDENTIQUE */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #1a1a2e; color: #e0e0e0; padding: 10px; }
        .container { max-width: 100%; background: #16213e; border-radius: 10px; padding: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        h1 { text-align: center; color: #f0a500; font-size: 1.2rem; margin-bottom: 15px; }
        
        .slots-container { display: flex; gap: 5px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap; }
        .slot-btn { background: #0f3460; border: 1px solid #533483; color: #aaa; padding: 5px 10px; cursor: pointer; border-radius: 5px; font-size: 0.8rem; }
        .slot-btn.active { background: #f0a500; color: #000; font-weight: bold; border-color: #f0a500; }
        .action-btn { background: #2196f3; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem; }
        .btn-clear { background: #ff4d4d; color: white; }

        .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        .input-wrapper { flex: 1; }
        label { display: block; margin-bottom: 3px; color: #888; font-size: 0.75rem; }
        input { width: 100%; padding: 8px; background: #0f3460; border: 1px solid #533483; color: white; border-radius: 5px; }
        
        .editor-panel { margin-bottom: 15px; }
        .editor-header { color: #f0a500; font-size: 0.8rem; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        textarea#strategyScript {
            width: 100%; height: 250px; 
            background: #080808; color: #d4d4d4; border: 1px solid #333;
            border-radius: 5px; padding: 10px; font-family: monospace; font-size: 11px;
            white-space: pre; overflow: auto;
        }

        .main-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button.big-btn { border: none; padding: 12px; border-radius: 5px; font-weight: bold; font-size: 0.85rem; cursor: pointer; color: #000; }
        .btn-load { background: #f0a500; }
        .btn-run { background: #4caf50; color: white; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .status-bar { text-align: center; font-size: 0.9rem; margin-bottom: 10px; }
        .logs-panel { background: #000; padding: 10px; border-radius: 5px; height: 200px; overflow-y: scroll; font-family: monospace; font-size: 10px; border: 1px solid #333; }
        .log-buy { color: #00ff00; }
        .log-sell { color: #ff0055; }
    </style>
</head>
<body>

<div class="container">
    <h1>üß¨ Emulateur GAS + VOLUME (365 Jours)</h1>
    
    <div class="slots-container">
        <button class="slot-btn active" onclick="selectSlot(1)">Slot 1</button>
        <button class="slot-btn" onclick="selectSlot(2)">Slot 2</button>
        <button class="action-btn" onclick="saveCurrentConfig()">üíæ SAVE</button>
    </div>

    <div class="input-group">
        <div class="input-wrapper">
            <label>D√©part ($)</label>
            <input type="number" id="startCap" value="20">
        </div>
        <div class="input-wrapper">
            <label>Fin ($)</label>
            <input type="text" id="finalCapDisplay" value="-" readonly>
        </div>
    </div>

    <div class="editor-panel">
        <div class="editor-header">
            <span>üëá Colle ton script ICI (Dispo: getLatestVolume()) :</span>
            <button class="action-btn btn-clear" onclick="clearScript()">üóëÔ∏è Effacer</button>
        </div>
        <textarea id="strategyScript" spellcheck="false" placeholder="// Exemple: 
// let vol = getLatestVolume();
// if (vol > 50) ..."></textarea>
    </div>

    <div class="main-actions">
        <button class="big-btn btn-load" id="btnLoad" onclick="loadDataBinance()">1. CHARGER DATA + VOL</button>
        <button class="big-btn btn-run" id="btnRun" onclick="runSim()" disabled>2. LANCER</button>
    </div>
    
    <div id="status" class="status-bar">En attente...</div>
    <div id="logs" class="logs-panel">Logs...</div>
</div>

<script>
// --- JAVASCRIPT SYSTEME ---
let btcPrices = []; 
let btcVolumes = []; // NOUVEAU : Stockage des volumes
let currentSlot = 1;

function selectSlot(num) {
    currentSlot = num;
    document.querySelectorAll('.slot-btn').forEach((btn, idx) => btn.className = (idx + 1 === num) ? 'slot-btn active' : 'slot-btn');
    loadSlotConfig(num);
}
function saveCurrentConfig() {
    const config = { capital: document.getElementById('startCap').value, script: document.getElementById('strategyScript').value };
    localStorage.setItem('gas_sim_slot_' + currentSlot, JSON.stringify(config));
    alert("Configuration sauvegard√©e !");
}
function loadSlotConfig(num) {
    const saved = localStorage.getItem('gas_sim_slot_' + num);
    if (saved) {
        const config = JSON.parse(saved);
        if(config.capital) document.getElementById('startCap').value = config.capital;
        document.getElementById('strategyScript').value = config.script;
    }
}
function clearScript() {
    document.getElementById('strategyScript').value = '';
}

// === CHARGEMENT DES DONN√âES BINANCE (PRIX + VOLUME) ===
async function loadDataBinance() {
    const status = document.getElementById('status');
    const btnLoad = document.getElementById('btnLoad');
    
    btnLoad.disabled = true;
    status.innerText = "Initialisation du t√©l√©chargement massif...";
    
    const TARGET_DAYS = 365;
    const TARGET_BOUGEES = TARGET_DAYS * 288; 
    const LIMIT = 1000;
    const NUM_REQUETES = Math.ceil(TARGET_BOUGEES / LIMIT);
    
    let allData = [];
    let endTime = Date.now(); 
    
    console.log(`Objectif : ${TARGET_BOUGEES} bougies (~${NUM_REQUETES} requ√™tes)`);

    try {
        for (let i = 0; i < NUM_REQUETES; i++) {
            status.innerText = `Chargement en cours (${i + 1}/${NUM_REQUETES}) - ${(allData.length/TARGET_BOUGEES*100).toFixed(0)}%`;
            
            const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=5m&limit=${LIMIT}&endTime=${endTime}`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (!data || data.length === 0) break;

            allData = data.concat(allData);
            endTime = data[0][0]; 

            await new Promise(resolve => setTimeout(resolve, 60)); 
        }

        if (allData.length > TARGET_BOUGEES) {
             allData = allData.slice(allData.length - TARGET_BOUGEES);
        }

        // --- MODIFICATION ICI : On inverse car on remonte le temps, puis on map ---
        // Binance renvoie [Open Time, Open, High, Low, Close, Volume, ...]
        // On a besoin que les donn√©es soient dans l'ordre chronologique (ancien -> r√©cent)
        // La boucle de fetch remonte le temps, donc 'allData' a le plus r√©cent en premier au niveau des blocs, 
        // mais l'API renvoie le bloc tri√© chrono.
        // Comme on a fait concat au d√©but, le tableau est: [R√©cent...Vieux]. Il faut inverser.
        // Note: Ma logique pr√©c√©dente concat√©nait √† la fin, mais endTime reculait. 
        // Correction de la logique de concat√©nation pour √™tre s√ªr de l'ordre :
        // L'API fetch endTime renvoie les donn√©es AVANT endTime.
        // Donc on doit faire allData = data.concat(allData) -> [Vieux ... R√©cent].
        // C'√©tait correct dans le code pr√©c√©dent.
        
        // Extraction : Index 4 = Close Price, Index 5 = Volume
        btcPrices = allData.map(c => parseFloat(c[4])); 
        btcVolumes = allData.map(c => parseFloat(c[5])); 
        
        status.innerHTML = `‚úÖ <b>${btcPrices.length}</b> bougies (Prix + Vol) charg√©es. Pr√™t !`;
        btnLoad.disabled = false;
        document.getElementById('btnRun').disabled = false;
        
    } catch(e) { 
        status.innerText = "Erreur Web: " + e.message; 
        console.error(e);
        btnLoad.disabled = false;
        document.getElementById('btnRun').disabled = true;
    }
}
// =======================================================


function runSim() {
    const userScript = document.getElementById('strategyScript').value;
    const startCap = parseFloat(document.getElementById('startCap').value);
    const logsDiv = document.getElementById('logs');
    const status = document.getElementById('status');
    
    if (btcPrices.length === 0) return alert("Clique sur CHARGER DONN√âES d'abord.");
    logsDiv.innerHTML = "";
    status.innerText = "Simulation en cours...";

    setTimeout(() => {
        // Moteur d'√©mulation
        const emulatorCode = `
            let _idx = 0;
            let _prices = pricesArray;
            let _volumes = volumesArray; // Injection des volumes
            
            let _mem = { 
                'TP_USDT': initialCapital, 
                'TP_BTC': 0.0, 
                'TP_AVG': 0.0 
            };
            let _logs = [];
            
            const REVOLUT_TAKER_FEE = 0.0009; 

            // Mock PropertiesService
            const PropertiesService = {
                getScriptProperties: () => ({
                    getProperty: (k) => _mem[k],
                    setProperty: (k, v) => _mem[k] = parseFloat(v), 
                    deleteProperty: (k) => delete _mem[k]
                })
            };
            const Logger = { log: (m) => {} };
            const ScriptApp = {
                getProjectTriggers: () => [],
                deleteTrigger: () => {},
                newTrigger: () => ({ timeBased: () => ({ everyMinutes: () => ({ create: () => {} }) }) })
            };
            const SpreadsheetApp = {
                getActiveSpreadsheet: () => ({
                    getSheetByName: (n) => ({
                        getRange: (r, c, nr, nc) => ({
                            getValue: () => _prices[_idx],
                            getValues: () => {
                                // Simule une lecture de plage, mais ici on simplifie
                                const end = _idx; 
                                const start = Math.max(0, end - nr + 1);
                                return _prices.slice(start, end + 1).map(p => [p]);
                            }
                        }),
                        getLastRow: () => _idx + 2,
                        appendRow: (arr) => {}
                    }),
                    insertSheet: () => {}
                })
            };

            // --- INJECTION DU SCRIPT UTILISATEUR ---
            if (userScript.trim().length > 0) {
                ${userScript}
            } else {
                function runTrendPullbackBot_5m() { return; }
            }
            
            // --- NOUVELLES FONCTIONS UTILES ---
            const getLatestPrice = () => _prices[_idx];
            const getPriceHistory = (limit) => _prices.slice(Math.max(0, _idx - limit + 1), _idx + 1);
            
            // Acc√®s aux volumes
            const getLatestVolume = () => _volumes[_idx];
            const getVolumeHistory = (limit) => _volumes.slice(Math.max(0, _idx - limit + 1), _idx + 1);
            
            // Fonction Logique Transaction
            const logAction = (type, price, assetAmount, usdtAmount, note) => {
                if (type === "BUY" || type === "SELL") {
                    let finalUSDT = usdtAmount;
                    let feeAmount = 0;
                    
                    if (type === "BUY") {
                        const usdtUsed = assetAmount * price; 
                        feeAmount = usdtUsed * REVOLUT_TAKER_FEE;
                        finalUSDT -= feeAmount; 
                        _mem['TP_USDT'] = finalUSDT;
                        _logs.push({ idx: _idx, action: type, price: price, usdt: finalUSDT, note: note + ' [Frais: ' + feeAmount.toFixed(4) + '$]' });
                    } else if (type === "SELL") {
                        const usdtReceived = assetAmount * price; 
                        feeAmount = usdtReceived * REVOLUT_TAKER_FEE;
                        finalUSDT -= feeAmount; 
                        _mem['TP_USDT'] = finalUSDT;
                        _logs.push({ idx: _idx, action: type, price: price, usdt: finalUSDT, note: note + ' [Frais: ' + feeAmount.toFixed(4) + '$]' });
                    }
                }
            };

            // --- BOUCLE DE SIMULATION ---
            for(let i = 200; i < _prices.length; i++) {
                _idx = i;
                try { 
                    if(typeof runTrendPullbackBot_5m === 'function') runTrendPullbackBot_5m(); 
                } catch(e){ }
            }

            const finalPrice = _prices[_prices.length - 1];
            const finalUSDT = parseFloat(_mem['TP_USDT']);
            const finalBTC = parseFloat(_mem['TP_BTC']);
            return { total: finalUSDT + (finalBTC * finalPrice), logs: _logs, trades: _logs.length };
        `;

        try {
            // On passe btcVolumes √† la VM
            const vm = new Function('pricesArray', 'volumesArray', 'initialCapital', 'userScript', emulatorCode);
            const result = vm(btcPrices, btcVolumes, startCap, userScript);
            
            const pnl = result.total - startCap;
            const color = pnl >= 0 ? "#4caf50" : "#ff4d4d";
            document.getElementById('finalCapDisplay').value = result.total.toFixed(2) + " $";
            status.innerHTML = `R√©sultat : <b style="color:${color}">${(pnl>0?"+":"") + pnl.toFixed(2)}$</b> (${result.trades} Trades)`;

            let logsHTML = "";
            const logsToDisplay = result.logs; 
            
            if(logsToDisplay.length === 0) {
                logsHTML = "Aucun trade effectu√©.";
            } else {
                logsToDisplay.forEach(l => {
                    const css = l.action === "BUY" ? "log-buy" : "log-sell";
                    logsHTML += `<div class="log-entry ${css}">[Bougie ${l.idx}] <b>${l.action}</b> @ ${l.price} | Solde: ${parseFloat(l.usdt).toFixed(2)} | ${l.note}</div>`;
                });
            }
            logsDiv.innerHTML = logsHTML;

        } catch(e) {
            alert("Erreur critique du MOTEUR : " + e.message);
            status.innerText = "Erreur script.";
        }
    }, 50);
}

selectSlot(1);
</script>
</body>
</html>
