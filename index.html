<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart DCA Emulator</title>
    <style>
        /* STYLE (CSS) */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #1a1a2e; color: #e0e0e0; padding: 10px; }
        .container { max-width: 100%; background: #16213e; border-radius: 10px; padding: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        h1 { text-align: center; color: #f0a500; font-size: 1.2rem; margin-bottom: 15px; }
        
        /* Boutons Slots */
        .slots-container { display: flex; gap: 5px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap; }
        .slot-btn { background: #0f3460; border: 1px solid #533483; color: #aaa; padding: 5px 10px; cursor: pointer; border-radius: 5px; font-size: 0.8rem; }
        .slot-btn.active { background: #f0a500; color: #000; font-weight: bold; border-color: #f0a500; }
        .action-btn { background: #2196f3; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem; }
        
        /* Nouveau bouton Effacer */
        .btn-clear { background: #ff4d4d; color: white; }

        /* Inputs */
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        .input-wrapper { flex: 1; }
        label { display: block; margin-bottom: 3px; color: #888; font-size: 0.75rem; }
        input { width: 100%; padding: 8px; background: #0f3460; border: 1px solid #533483; color: white; border-radius: 5px; }
        
        /* Zone de code (Noir) */
        .editor-panel { margin-bottom: 15px; }
        .editor-header { color: #f0a500; font-size: 0.8rem; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        textarea#strategyScript {
            width: 100%; height: 250px; /* Moins haut pour mobile */
            background: #080808; color: #d4d4d4; border: 1px solid #333;
            border-radius: 5px; padding: 10px; font-family: monospace; font-size: 11px;
            white-space: pre; overflow: auto;
        }

        /* Gros boutons d'action */
        .main-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button.big-btn { border: none; padding: 12px; border-radius: 5px; font-weight: bold; font-size: 0.85rem; cursor: pointer; color: #000; }
        .btn-load { background: #f0a500; }
        .btn-run { background: #4caf50; color: white; }
        button:disabled { opacity: 0.5; }

        /* Logs */
        .status-bar { text-align: center; font-size: 0.9rem; margin-bottom: 10px; }
        .logs-panel { background: #000; padding: 10px; border-radius: 5px; height: 200px; overflow-y: scroll; font-family: monospace; font-size: 10px; border: 1px solid #333; }
        .log-buy { color: #00ff00; }
        .log-sell { color: #ff0055; }
    </style>
</head>
<body>

<div class="container">
    <h1>üß¨ Emulateur GAS (Mobile)</h1>
    
    <div class="slots-container">
        <button class="slot-btn active" onclick="selectSlot(1)">Slot 1</button>
        <button class="slot-btn" onclick="selectSlot(2)">Slot 2</button>
        <button class="action-btn" onclick="saveCurrentConfig()">üíæ SAVE</button>
    </div>

    <div class="input-group">
        <div class="input-wrapper">
            <label>D√©part ($)</label>
            <input type="number" id="startCap" value="20">
        </div>
        <div class="input-wrapper">
            <label>Fin ($)</label>
            <input type="text" id="finalCapDisplay" value="-" readonly>
        </div>
    </div>

    <div class="editor-panel">
        <div class="editor-header">
            <span>üëá Colle ton script ICI (Zone noire) :</span>
            <button class="action-btn btn-clear" onclick="clearScript()">üóëÔ∏è Effacer</button>
        </div>
        <textarea id="strategyScript" spellcheck="false" placeholder="// Colle ton script ici...">
// =============================================================
// === STRAT√âGIE V5.0 - TRIPLE FILTRE D'IMPULSION (CORRIG√âE) ===
// =============================================================

// ATTENTION : Pour un backtest pr√©cis, l'√©mulateur force l'√©tat de d√©part √† 20$
// La fonction tp_loadState ne doit PAS √™tre utilis√©e dans runTrendPullbackBot_5m() ici.

const TP_CFG = {
  // --- Trading ---
  MIN_ORDER_USDT: 1,           
  USE_PERCENT_CAPITAL: 0.2,    
  TAKE_PROFIT: 0.025,          
  STOP_LOSS: 0.007,            
  FEES_RATE: 0.0009,           

  // --- Indicateurs Techniques ---
  SMA_FAST: 10,                
  SMA_MEDIUM: 20,              
  SMA_SLOW: 50,                
  TREND_STRENGTH_MIN: 0.003,   

  // --- Pullback / Retrait ---
  PULLBACK_LOOKBACK: 12,       
  PULLBACK_MIN: 0.003,         
  PULLBACK_MAX: 0.01,          
};

// Fonctions qui ne changent pas : getLatestPrice, getPriceHistory, logAction...
// tp_saveState est utilis√©e pour la sauvegarde. tp_loadState n'est pas utilis√©e.

function tp_saveState(state) {
  const properties = PropertiesService.getScriptProperties();
  properties.setProperty("TP_USDT", state.usdt);
  properties.setProperty("TP_BTC", state.btc);
  properties.setProperty("TP_AVG", state.avg);
}

function calculateSMA(prices, period) {
  if (prices.length < period) return null;
  const slice = prices.slice(prices.length - period);
  return slice.reduce((a, b) => a + b, 0) / period;
}

function getTripleTrendSignal(prices) {
    if (prices.length < TP_CFG.SMA_SLOW) return { direction: "WAIT", strength: 0 };
    
    const fastSMA = calculateSMA(prices, TP_CFG.SMA_FAST);
    const mediumSMA = calculateSMA(prices, TP_CFG.SMA_MEDIUM);
    const slowSMA = calculateSMA(prices, TP_CFG.SMA_SLOW);

    const isTripleBullish = fastSMA > mediumSMA && mediumSMA > slowSMA;
    const isTripleBearish = fastSMA < mediumSMA && mediumSMA < slowSMA;

    const strength = Math.abs(fastSMA - slowSMA) / slowSMA;

    if (isTripleBullish) {
        return { direction: "UP", strength: strength };
    } else if (isTripleBearish) {
        return { direction: "DOWN", strength: strength };
    } else {
        return { direction: "WAIT", strength: 0 };
    }
}

function getPullbackDrop(prices) {
  const lookbackPrices = prices.slice(Math.max(0, prices.length - TP_CFG.PULLBACK_LOOKBACK));
  if (lookbackPrices.length === 0) return 0;
  const highRecent = Math.max(...lookbackPrices);
  const currentPrice = lookbackPrices[lookbackPrices.length - 1];
  const drop = (highRecent - currentPrice) / highRecent;
  return { drop: drop, high: highRecent };
}


// Cette fonction DOIT accepter initialCapital en param√®tre
function runTrendPullbackBot_5m() {
  // Les fonctions GAS (getLatestPrice, getPriceHistory, logAction) doivent √™tre d√©finies plus haut
  // ou l'√©mulateur doit les simuler correctement.

  const currentPrice = getLatestPrice();
  if (!currentPrice || currentPrice === 0) return;

  // IMPORTANT : L'√©tat initial DOIT venir du moteur de l'√©mulateur (pas de tp_loadState ici)
  // L'√©mulateur g√®re la r√©initialisation √† 20$

  // Simule l'√©tat (le moteur d√©finit l'√©tat initial √† 20$ avant d'appeler cette fonction)
  let state = {
    usdt: parseFloat(PropertiesService.getScriptProperties().getProperty("TP_USDT")),
    btc: parseFloat(PropertiesService.getScriptProperties().getProperty("TP_BTC")),
    avg: parseFloat(PropertiesService.getScriptProperties().getProperty("TP_AVG"))
  };

  const history = getPriceHistory(TP_CFG.SMA_SLOW);
  if (history.length < TP_CFG.SMA_SLOW) return; 

  const trend = getTripleTrendSignal(history);
  const pullback = getPullbackDrop(history);

  // --- 1. Gestion des positions existantes (SELL) ---
  if (state.btc > 0) {
    const profit = (currentPrice - state.avg) / state.avg;
    
    // TAKE PROFIT
    if (profit >= TP_CFG.TAKE_PROFIT) {
      const btcSold = state.btc;
      const usdtEarned = btcSold * currentPrice * (1 - TP_CFG.FEES_RATE);
      state.usdt = usdtEarned;
      state.btc = 0.0;
      state.avg = 0.0;
      const note = `TAKE PROFIT +${(TP_CFG.TAKE_PROFIT * 100).toFixed(1)}%`;
      logAction("SELL", currentPrice, btcSold, usdtEarned, note);
      tp_saveState(state);
      return;
    }
    
    // STOP LOSS
    if (profit <= -TP_CFG.STOP_LOSS) {
      const btcSold = state.btc;
      const usdtEarned = btcSold * currentPrice * (1 - TP_CFG.FEES_RATE);
      state.usdt = usdtEarned;
      state.btc = 0.0;
      state.avg = 0.0;
      const note = `STOP LOSS ${(-TP_CFG.STOP_LOSS * 100).toFixed(1)}%`;
      logAction("SELL", currentPrice, btcSold, usdtEarned, note);
      tp_saveState(state);
      return;
    }
  }

  // --- 2. Recherche d'une opportunit√© (BUY) ---
  if (state.btc === 0 && 
      trend.direction === "UP" && 
      trend.strength >= TP_CFG.TREND_STRENGTH_MIN) {
    
    const drop = pullback.drop;
    if (drop >= TP_CFG.PULLBACK_MIN && drop <= TP_CFG.PULLBACK_MAX) {
      
      let invest = Math.max(TP_CFG.MIN_ORDER_USDT, state.usdt * TP_CFG.USE_PERCENT_CAPITAL);
      if (invest > state.usdt) invest = state.usdt; 
      if (invest < TP_CFG.MIN_ORDER_USDT) return;

      const usdtUsed = invest;
      const btcBought = (usdtUsed / currentPrice) * (1 - TP_CFG.FEES_RATE);
      
      state.usdt -= usdtUsed;
      state.btc += btcBought;
      state.avg = currentPrice; 
      
      const note = `BUY TripleFilter (repli ${(drop * 100).toFixed(2)}% sous high r√©cent)`;
      logAction("BUY", currentPrice, btcBought, usdtUsed, note);
      tp_saveState(state);
      return;
    }
  }
}

function createTrendPullbackTrigger5m() {
  // code non n√©cessaire pour l'√©mulation
}
</textarea>
    </div>

    <div class="main-actions">
        <button class="big-btn btn-load" onclick="loadDataBinance()">1. CHARGER DONN√âES (7 Jours / 5 Min)</button>
        <button class="big-btn btn-run" id="btnRun" onclick="runSim()" disabled>2. LANCER</button>
    </div>
    
    <div id="status" class="status-bar">En attente...</div>
    <div id="logs" class="logs-panel">Logs...</div>
</div>

<script>
// --- JAVASCRIPT SYSTEME (NE PAS TOUCHER) ---
let btcData = []; 
let currentSlot = 1;

function selectSlot(num) {
    currentSlot = num;
    document.querySelectorAll('.slot-btn').forEach((btn, idx) => btn.className = (idx + 1 === num) ? 'slot-btn active' : 'slot-btn');
    loadSlotConfig(num);
}
function saveCurrentConfig() {
    const config = { capital: document.getElementById('startCap').value, script: document.getElementById('strategyScript').value };
    localStorage.setItem('gas_sim_slot_' + currentSlot, JSON.stringify(config));
    alert("Configuration sauvegard√©e !");
}
function loadSlotConfig(num) {
    const saved = localStorage.getItem('gas_sim_slot_' + num);
    if (saved) {
        const config = JSON.parse(saved);
        document.getElementById('startCap').value = config.capital;
        document.getElementById('strategyScript').value = config.script;
    }
}
// NOUVELLE FONCTION : EFFACER LE SCRIPT
function clearScript() {
    document.getElementById('strategyScript').value = '';
}

// === CHARGEMENT DES DONN√âES BINANCE ===
async function loadDataBinance() {
    const status = document.getElementById('status');
    status.innerText = "Chargement (1/2)...";
    try {
        // 1. R√©cup√©rer les 1000 bougies les plus r√©centes
        const url1 = "https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=5m&limit=1000";
        const response1 = await fetch(url1);
        const d1 = await response1.json();
        
        // Trouver la date de la bougie la plus ancienne du premier lot
        const oldestTime = d1[0][0]; 

        status.innerText = "Chargement (2/2)...";
        
        // 2. R√©cup√©rer les 1000 bougies pr√©c√©dentes, en utilisant 'endTime'
        const url2 = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=5m&limit=1000&endTime=${oldestTime}`;
        const response2 = await fetch(url2);
        const d2 = await response2.json();
        
        // Concat√©ner (d2 d'abord pour avoir la chronologie correcte)
        const full = d2.concat(d1);
        
        // Extraire les prix de cl√¥ture
        btcData = full.map(c => parseFloat(c[4])); 
        
        status.innerHTML = `‚úÖ <b>${btcData.length}</b> bougies charg√©es (7 jours).`;
        document.getElementById('btnRun').disabled = false;
    } catch(e) { 
        status.innerText = "Erreur Web: √âchec du chargement des donn√©es. " + e.message; 
        document.getElementById('btnRun').disabled = true;
    }
}
// =======================================================


function runSim() {
    const userScript = document.getElementById('strategyScript').value;
    const startCap = parseFloat(document.getElementById('startCap').value);
    const logsDiv = document.getElementById('logs');
    const status = document.getElementById('status');
    
    if (btcData.length === 0) return alert("Clique sur CHARGER DATA d'abord.");
    logsDiv.innerHTML = "";

    // Moteur d'√©mulation
    const emulatorCode = `
        let _idx = 0;
        let _prices = pricesArray;
        // CORRECTION MAJEURE: Force la r√©initialisation de la m√©moire TP_USDT √† initialCapital
        // pour corriger le bug de persistance du solde faible.
        let _mem = { 'TP_USDT': initialCapital, 'TP_BTC': 0.0, 'TP_AVG': 0.0 };
        let _logs = [];

        const PropertiesService = {
            getScriptProperties: () => ({
                getProperty: (k) => _mem[k],
                setProperty: (k, v) => _mem[k] = parseFloat(v), 
                deleteProperty: (k) => delete _mem[k]
            })
        };
        const Logger = { log: (m) => {} };
        const ScriptApp = {
            getProjectTriggers: () => [],
            deleteTrigger: () => {},
            newTrigger: () => ({ timeBased: () => ({ everyMinutes: () => ({ create: () => {} }) }) })
        };
        const SpreadsheetApp = {
            getActiveSpreadsheet: () => ({
                getSheetByName: (n) => ({
                    getRange: (r, c, nr, nc) => ({
                        getValue: () => _prices[_idx],
                        getValues: () => {
                            // Simulation historique simple
                            const end = _idx; 
                            const start = Math.max(0, end - nr + 1);
                            return _prices.slice(start, end + 1).map(p => [p]);
                        }
                    }),
                    getLastRow: () => _idx + 2,
                    appendRow: (arr) => {
                        if (arr[1] === "BUY" || arr[1] === "SELL") {
                            _logs.push({ idx: _idx, action: arr[1], price: arr[2], usdt: arr[4], note: arr[6] });
                        }
                    }
                }),
                insertSheet: () => {}
            })
        };

        ${userScript}

        for(let i = 50; i < _prices.length; i++) {
            _idx = i;
            try { if(typeof runTrendPullbackBot_5m === 'function') runTrendPullbackBot_5m(); } catch(e){}
        }

        const finalPrice = _prices[_prices.length - 1];
        const finalUSDT = parseFloat(_mem['TP_USDT']);
        const finalBTC = parseFloat(_mem['TP_BTC']);
        return { total: finalUSDT + (finalBTC * finalPrice), logs: _logs, trades: _logs.length };
    `;

    try {
        const vm = new Function('pricesArray', 'initialCapital', emulatorCode);
        // Utilise startCap comme capital initial
        const result = vm(btcData, startCap);
        
        const pnl = result.total - startCap;
        const color = pnl >= 0 ? "#4caf50" : "#ff4d4d";
        document.getElementById('finalCapDisplay').value = result.total.toFixed(2) + " $";
        status.innerHTML = `R√©sultat : <b style="color:${color}">${(pnl>0?"+":"") + pnl.toFixed(2)}$</b> (${result.trades} Trades)`;

        result.logs.forEach(l => {
            const css = l.action === "BUY" ? "log-buy" : "log-sell";
            logsDiv.innerHTML += `<div class="log-entry ${css}">[${l.idx}] <b>${l.action}</b> @ ${l.price} | Solde: ${parseFloat(l.usdt).toFixed(2)} | ${l.note}</div>`;
        });
    } catch(e) {
        alert("Erreur dans VOTRE script (zone noire) : " + e.message);
    }
}
</script>
</body>
</html>
